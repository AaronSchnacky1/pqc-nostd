# Phase 2 Implementation Plan - Software Integrity Test

**Goal**: Implement FIPS 140-3 Section 6.10.1 Software Integrity Test.
**Strategy**: Build-time HMAC generation (or post-build injection) and runtime verification.

## üìã Tasks

### 1. Platform-Specific Code Boundaries (Task 2.1)
- [ ] Modify `src/integrity.rs` to add helper functions for finding code start/end.
- [ ] Implement for **Windows** (using `__ImageBase` or PE headers).
- [ ] Implement for **Linux** (using `_etext` or `__executable_start`).
- [ ] Add `#[cfg(target_os = "...")]` gates.

### 2. Build-Time HMAC Infrastructure (Task 2.2)
- [ ] Create `build.rs` to handle build configuration.
- [ ] **Challenge**: `build.rs` runs *before* linking, so it cannot hash the final binary.
- [ ] **Solution**: 
    1. Create a placeholder constant for the HMAC in `src/integrity_data.rs` (generated by `build.rs`).
    2. Create a post-build script (`scripts/inject_hmac.rs`) that:
        - Reads the compiled binary.
        - Calculates HMAC-SHA-256 of the text section (or full file excluding HMAC).
        - Overwrites the placeholder in the binary with the real HMAC.

### 3. Integrate into POST (Task 2.3)
- [ ] Update `src/preop.rs` to call `integrity_check()`.
- [ ] Pass the dynamically detected `code_start` and `code_len`.
- [ ] Pass the expected HMAC (from the injected constant).

### 4. Verification (Task 2.4)
- [ ] Verify clean build passes.
- [ ] Verify modifying the binary causes failure.

## üõ†Ô∏è Proposed File Structure

- `src/integrity.rs`: Core logic + platform detection.
- `src/integrity_data.rs`: Generated file containing `EXPECTED_HMAC` (placeholder initially).
- `build.rs`: Generates `src/integrity_data.rs`.
- `scripts/inject_hmac.rs`: Post-processing tool.

## ‚ö†Ô∏è Notes
- This requires `unsafe` code to read memory boundaries.
- `no_std` environment makes file I/O impossible at runtime, so we must rely on memory mapping.
